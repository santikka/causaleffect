% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/join.R
\name{join}
\alias{join}
\title{Join}
\usage{
join(J, D, vari, cond, S, M, O, G.unobs, G, G.obs, topo)
}
\arguments{
\item{J}{character vector. Joint set \code{P(J|D)}; already processed and included in joint distribution
from previous \code{\link{simplify}} iteration. Initially, may be empty for the starting point of
the joint distribution. \code{vari} is added to expand it if d-separation conditions are met.}

\item{D}{character vector. Term \code{P(V|C) := P(Vk|Ck)}; set of variables that condition the joint distribution.
\code{Join} checks and updates \code{D} as necessary to maintain the validity of the joint distribution
when combined with \code{vari}.}

\item{vari}{character scalar. Current variable being considered for inclusion in the joint distribution.}

\item{cond}{character vector. Set of variables that condition the current variable \code{vari}. \code{Join} uses \code{cond}
to evaluate conditional independence and determine if \code{vari} can be added to \code{J}.}

\item{S}{likely a character vector. Not used directly in \code{join}. Current summation variable.}

\item{M}{character vector. Missing variables (variables not contained within the expression).}

\item{O}{character vector. Observed variables (variables contained within the expression).}

\item{G.unobs}{igraph object created with \code{igraph::unobserved.graph(G)}. Separate graph that turns bidirected edges into explicit nodes for unobserved confounders.}

\item{G}{igraph object created with \code{igraph::graph.formula()}. Main graph G. Includes bidirected edges.}

\item{G.obs}{igraph object created with \code{igraph::observed.graph(G)}. Separate graph that does not contain bidirected edges (only contains the directed edges with observed nodes).}

\item{topo}{igraph list object created with \code{igraph::topological.sort} and \code{igraph::get.vertex.attribute}. The topological ordering of the vertices in graph G.}
}
\value{
\code{Join} returns the joint result, or the original result if none of the conditions for joining were met.
}
\description{
\code{Join} and \code{insert} are essentially two variations of the underlying procedure of determining whether the terms of the atomic expression actually represent a joint distribution. \code{Join} is called when we are processing terms that already exist in the expression.
Attempts to combine two terms: the joint term \code{P(J|D)} obtained from \code{simplify()} and the
term \code{P(V|C) := P(Vk|Ck)} of the current iteration step. The goal is to
determine if these terms can be combined based on the d-separation criteria in the graph \code{G}.
}
\examples{
\dontrun{

# defining graph information for G_1 using igraph
G_1 <- graph.formula(x -+ y, z -+ x, z -+ y , x -+ z, z -+ x, simplify = FALSE)
G_1 <- set.edge.attribute(graph = G_1, name = "description", index = c(4,5), value = "U")

# defining observed nodes of graph G_1 using igraph
G_1.obs <- observed.graph(G_1)

# defining unobserved nodes of graph G_1 using igraph
G_1.unobs <- unobserved.graph(G_1)

# defining topological sort of graph G_1 using igraph
topo_1 <- igraph::topological.sort(G_1.obs)
topo_1 <- igraph::get.vertex.attribute(G_1, "name")[topo_1]

# we can obtain the following from running simplify(P_1, topo_1, G_1.unobs, G_1,
# G_1.obs) with break points (the browser() function). I added print statements
# after step #5 in simplify():
  # Step 6 - Inside nested while loop before join operation
  # P$children[[k]]$var: y (this represents vari in simplify())
  # P$children[[k]]$cond: z x (this represents cond in simplify())
  # P$sumset[j]: z (this reprensents S in simplify())

J_1 <- character()
D_1 <- character()
vari_1 <- "y"
cond_1 <- c("z", "x")
S_1 <- "z"
M_1 <- "x"
O_1 <- c("z", "y")

# we can obtain the following from the graph information:
# G.unobs = G_1.unobs
# G = G_1
# G.obs = G_1.obs
# topo = topo_1

# we expect the output from this to be:
# [1] "y"
# [2] "z" "x"

join(J_1, D_1, vari_1, cond_1, S_1, M_1, O_1, G_1.unobs, G_1, G_1.obs, topo_1)
}

}
\references{
Tikka, S., & Karvanen, J. (2017). Simplifying probabilistic expressions in causal inference. Journal of Machine Learning Research, 18(36), 1-30.
}
\seealso{
\code{\link{causal.effect}}, \code{\link{parse.expression}}, \code{\link{get.expression}}, \code{\link{probability}}

\code{\link{simplify}}, \code{\link{wrap.dSep}}, \code{\link{insert}}
}
\author{
Haley Hummel,
Psychology PhD student at Oregon State University
}
\concept{causal inference}
\concept{graph theory}
\concept{probabilistic expressions}
\keyword{manip}
\keyword{math}
\keyword{models}
\keyword{utilities}
